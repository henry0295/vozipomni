#!KAMAILIO
# Kamailio Configuration for VozipOmni WebRTC Support

####### Defined Values #########

# Flag definitions
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

####### Global Parameters #########

debug=2
log_stderror=yes
memdbg=5
memlog=5

fork=yes
children=4

# Aliases - Cambiar por tu dominio
# alias="vozipomnirt.com"

# Listening interfaces
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060
listen=tls:0.0.0.0:5061
listen=tcp:0.0.0.0:8080

# TLS Configuration
enable_tls=yes
tls_port_no=5061

####### Modules Section ########

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "db_redis.so"
loadmodule "tls.so"
loadmodule "websocket.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"

####### Routing Logic ########

# Main SIP request routing logic
request_route {
    # Per request initial checks
    route(REQINIT);
    
    # NAT detection
    route(NATDETECT);
    
    # Handle requests within SIP dialogs
    route(WITHINDLG);
    
    # Handle registrations
    route(REGISTRAR);
    
    # Handle routing to Asterisk
    route(RELAY);
}

# Handle initial requests
route[REQINIT] {
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
        sl_send_reply("200", "OK");
        exit;
    }
    
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }
    
    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }
    
    if(!sanity_check("1511", "7")) {
        xlog("Malformed SIP message from $si:$sp\n");
        exit;
    }
}

# Caller NAT detection
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(FLT_NATS);
    }
    return;
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;
    
    if (loose_route()) {
        route(DLGURI);
        if (is_method("BYE")) {
            setflag(FLT_ACC);
            setflag(FLT_ACCFAILED);
        } else if (is_method("ACK")) {
            route(NATMANAGE);
        } else if (is_method("NOTIFY")) {
            record_route();
        }
        route(RELAY);
        exit;
    }
    
    if (is_method("ACK")) {
        if (t_check_trans()) {
            route(RELAY);
            exit;
        } else {
            exit;
        }
    }
    
    sl_send_reply("404","Not here");
    exit;
}

# URI update for dialog requests
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# REGISTRAR - WebRTC and SIP registrations
route[REGISTRAR] {
    if (!is_method("REGISTER")) return;
    
    # WebSockets need to be handled specially
    if (proto == WS || proto == WSS) {
        xlog("L_INFO", "WebSocket REGISTER from $si:$sp\n");
        
        # Store in Redis (location table)
        if (!save("location")) {
            sl_reply_error();
        }
        exit;
    }
    
    # Regular SIP REGISTER
    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# RTPEngine management
route[NATMANAGE] {
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(FLB_NATB);
            }
        }
    }
    
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;
    
    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    
    if (is_reply()) {
        if(isbflagset(FLB_NATB)) {
            if(is_first_hop())
                set_contact_alias();
        }
    }
    
    # RTPEngine control
    if (nat_uac_test("8")) {
        rtpengine_manage("replace-origin replace-session-connection");
    }
}

# Relay to Asterisk
route[RELAY] {
    # Enable additional event routes for forwarded requests
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }
    
    # Forward to Asterisk
    $du = "sip:asterisk:5060";
    
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Manage SIP replies
onreply_route[MANAGE_REPLY] {
    xdbg("incoming reply\n");
    
    if (nat_uac_test("1")) {
        fix_nated_contact();
    }
    
    route(NATMANAGE);
}

# Manage failure responses
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);
    
    if (t_is_canceled()) {
        exit;
    }
}

# WebSocket event route
event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}
